#AUTOGENERATED! DO NOT EDIT! File to edit: dev/twisted_attractor.ipynb (unless otherwise specified).

__all__ = ['TwistedAttractor']

#Cell
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt

#Cell
from .twisted_torus import create_twisted_inh_weights, create_twisted_domain

class TwistedAttractor(nn.Module):
    M = torch.FloatTensor([[ 0.,  1.,  0., -1.],
                           [ 1.,  0., -1.,  0.]])

    def __init__(self, n=8, sigma=0.2, dt=0.5, v=0.1, noise=0.001 ,cell_pos=None):
        super().__init__()

        self.dt = dt
        self.n = n
        self.noise = noise

        if   cell_pos is   None  : p = create_twisted_domain(n)
        else: p = cell_pos

        self.cell_pos  = p

        self.W = torch.Tensor(4, n**2, n**2)
        for i in range(4):
            off = v * self.M[:,[i]]
            self.W[i] = create_twisted_inh_weights(p - off, p, sigma=sigma)


    def activation(self, x):
        return F.relu6(x)


    def to_attr_control(self, v):
        u = 1. + torch.matmul(v, self.M)
        return u


    def forward(self, x, v, b, dt=None):
        """
        Evolves the dynamical system for ONE time-step with
        initial condition `x`, and control signal `v`,
        and feedforward input `b`
        """
        if dt is None:
            dt = self.dt

        f = self.activation
        W = self.W

        u = self.to_attr_control(v)
        x = x + torch.randn_like(x)*self.noise
        y = torch.matmul(x, W); # assert(y.max() <=0)
        y = torch.einsum("ubj, bu -> bj", y, u)

        x_dot = -x + f(y + b)

        return x + dt*x_dot


    def evolve(self, x, V, B, dt=None):
        """
        Evolves the dynamical system for MULTIPLE time-steps with
        initial condition `x`, and time dependent control signal `V`,
        and time dependent feedforward input `B`
        """
        T = V.size(0)
        n = x.size(-1)

        Y = torch.zeros(T,n)
        Y[0, :] = x

        for t in range(1,T):
            Y[t,:] = self.forward(Y[t-1,:], V[t-1,:], B[t-1,:], dt)

        return Y

