#AUTOGENERATED! DO NOT EDIT! File to edit: dev/twisted_torus.ipynb (unless otherwise specified).

__all__ = ['return_to_twisted_torus', 'twisted_distance', 'create_twisted_domain', 'create_twisted_inh_weights',
           'TwistedTorus', 't']

#Cell
import numpy as np
import torch
import matplotlib.pyplot as plt

#Cell
def return_to_twisted_torus(x):
    h = np.sqrt(3)/2.
    x_ = torch.zeros_like(x)

    s = ((x[1]<0) + (x[1]>=h)).float()

    x_[0] = x[0] + s * 0.5
    x_[0] = x_[0]%1.
    x_[1] = x[1]%h

    return x_

#Cell
def twisted_distance(X, Y):
    h = np.sqrt(3)/2.
    off = torch.tensor([
        [0 ,0],
        [1 ,0],
        [-1,0],
        [0.5,h],
        [-0.5,h],
        [0.5,-h],
        [-0.5,-h],
    ]).t()
    x = return_to_twisted_torus(X)
    y = return_to_twisted_torus(Y)

    y = y.view(2,-1,1) + off.view(2,1,7)

    diff = x.view(2,1,-1, 1) - y.view(2,-1,1,7)

    norm = torch.norm(diff, dim=0)
    dist, _ = torch.min(norm, dim=-1)

    return dist


#Cell
def create_twisted_domain(n):
    h = np.sqrt(3)/2.
    ticks = torch.arange(0,n, dtype=float)/n
    m     = torch.meshgrid([ticks, ticks])
    g = torch.stack(m).view(2,-1).float()
    g[1] = g[1]*h

    return g

#Cell
def create_twisted_inh_weights(x, y, sigma):
    d = twisted_distance(x, y)
    W = np.exp(-d**2/(2*sigma**2)) - 1.
    W = W - torch.diag(W.diag())
    return W.float()

#Cell

class TwistedTorus(object):
    def __init__(self, p=None, n = 10):

        h = int(np.sqrt(3)/2. * n)
        self.shape = (h, n)
#         self.c = np.stack(np.indices((h, n)), axis=2).reshape((-1,2))

        m = torch.meshgrid([
                torch.arange(0,h, dtype=float)/h*np.sqrt(3)/2.,
                torch.arange(0,n, dtype=float)/n
                ])

        self.c = torch.stack(m).float().view(2,-1)
        if p is None:
            p = torch.rand(2)
            p = p*torch.tensor([np.sqrt(3)/2., 1])

        self.p = p

    def __call__(self, v=None):
        if not v is None:
            self.update(v)

        return self.cell_activity().view(*self.shape)

    def cell_activity(self):
        d = twisted_distance(self.p, self.c)
        print(d.shape)
        return torch.exp(-d**2/0.01)

    def update(self,v):
        p  = self.p
        p_ = p + v
        p_ = return_to_twisted_torus(p_)
        self.p = p_

        return p_


